
import 'dotenv/config';
import { redisService } from '../src/services/redis.service';
import { apiKeyService } from '../src/services/apiKey.service';
import { logger } from '../src/utils/logger';
import { config } from '../src/config';

const printUsage = () => {
  console.log(`
  API Key Management Tool (v2.0)
  ---------------------------------
  Usage: npm run manage-keys -- <command> [arguments]

  Commands:
    create <clientId> [--limit <number>]
      - Creates a key for a client. Monthly limit defaults to ${config.apiKey.defaultMonthlyLimit}.
      - e.g., npm run manage-keys -- create billing-service --limit 5000

    list
      - Lists all API keys with their status and usage data.

    revoke <clientId>
      - Permanently deletes a client's API key.
      - e.g., npm run manage-keys -- revoke billing-service

    pause <clientId>
      - Deactivates a client's API key temporarily.

    resume <clientId>
      - Reactivates a paused client's API key.

    update-limit <clientId> <newLimit>
      - Updates the monthly OTP limit for a client.
      - e.g., npm run manage-keys -- update-limit billing-service 10000

    stats <clientId>
      - Shows the total OTP generation count for a client.
  `);
};

const main = async () => {
  await redisService.connect();
  const args = process.argv.slice(2);
  const command = args[0];

  try {
    switch (command) {
      case 'create': {
        const clientId = args[1];
        if (!clientId) throw new Error('Client ID is required.');
        const limitArgIndex = args.indexOf('--limit');
        const limit = limitArgIndex !== -1 ? parseInt(args[limitArgIndex + 1], 10) : config.apiKey.defaultMonthlyLimit;
        if (isNaN(limit)) throw new Error('Invalid limit specified.');

        const newKey = await apiKeyService.createKey(clientId, limit);
        logger.info(`Successfully created API key for client "${clientId}".`);
        console.log(`\nðŸ”‘ New API Key: ${newKey}\n`);
        logger.warn('Store this key securely. It cannot be retrieved again.');
        break;
      }
      case 'list': {
        const keys = await apiKeyService.listAllKeys();
        if (keys.length === 0) {
            logger.info('No API keys found.');
            return;
        }
        console.table(keys.map(k => ({
            'Client ID': k.clientId,
            'Status': k.status,
            'Monthly Usage': `${k.usage}/${k.monthlyLimit}`,
            'Period Start': k.periodStart,
            'Created At': k.createdAt
        })));
        break;
      }
      case 'revoke': {
        const clientId = args[1];
        if (!clientId) throw new Error('Client ID is required.');
        const success = await apiKeyService.revokeKeyByClientId(clientId);
        logger.info(success ? `API key for ${clientId} revoked.` : `Client ID ${clientId} not found.`);
        break;
      }
      case 'pause':
      case 'resume': {
        const clientId = args[1];
        if (!clientId) throw new Error('Client ID is required.');
        const status = command === 'pause' ? 'paused' : 'active';
        const success = await apiKeyService.updateKeyByClientId(clientId, { status });
        logger.info(success ? `API key for ${clientId} set to ${status}.` : `Client ID ${clientId} not found.`);
        break;
      }
      case 'update-limit': {
        const clientId = args[1];
        const newLimit = parseInt(args[2], 10);
        if (!clientId) throw new Error('Client ID is required.');
        if (isNaN(newLimit)) throw new Error('A valid numeric limit is required.');
        const success = await apiKeyService.updateKeyByClientId(clientId, { monthlyLimit: newLimit });
        logger.info(success ? `Monthly limit for ${clientId} updated to ${newLimit}.` : `Client ID ${clientId} not found.`);
        break;
      }
      case 'stats': {
        const clientId = args[1];
        if (!clientId) throw new Error('Client ID is required.');
        const totalCount = await apiKeyService.getStats(clientId);
        logger.info(`Total OTPs generated by '${clientId}': ${totalCount}`);
        break;
      }
      default:
        printUsage();
    }
  } catch (error: any) {
    logger.error(`Operation failed: ${error.message}`);
  } finally {
    await redisService.disconnect();
  }
};

main();